#!/usr/bin/env python3
"""
Generate Python module with LCC program binaries for cocotb testing.

Usage:
    python3 scripts/generate_lcc_programs.py

This script assembles all .s files in lcc_samples/ and generates a Python
module with the binary data as byte lists for direct import in cocotb tests.
"""

import os
import sys
from pathlib import Path

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from neander_assembly import NeanderLoader, AssemblyError

SAMPLES_DIR = PROJECT_ROOT / "lcc_samples"
OUTPUT_DIR = PROJECT_ROOT / "cocotb_tests_lcc"
OUTPUT_FILE = OUTPUT_DIR / "lcc_programs.py"


def main():
    """Generate the Python module with program binaries."""

    # Find all .s files
    asm_files = sorted(SAMPLES_DIR.glob("*.s"))

    if not asm_files:
        print(f"No .s files found in {SAMPLES_DIR}", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(asm_files)} assembly files")

    # Assemble each file
    programs = {}
    errors = []

    loader = NeanderLoader(add_startup=True)

    for asm_file in asm_files:
        name = asm_file.stem
        print(f"  Assembling {name}...", end=" ")

        try:
            binary = loader.assemble_file(str(asm_file))
            programs[name] = binary
            print(f"OK ({len(binary)} bytes)")
        except (AssemblyError, Exception) as e:
            errors.append((name, str(e)))
            print(f"ERROR: {e}")

    # Generate Python module
    print(f"\nGenerating {OUTPUT_FILE}...")

    with open(OUTPUT_FILE, "w") as f:
        f.write('"""\n')
        f.write('Auto-generated LCC program binaries for cocotb testing.\n')
        f.write('\n')
        f.write('Generated by: python3 scripts/generate_lcc_programs.py\n')
        f.write('              or: just generate-python\n')
        f.write('\n')
        f.write('Usage in cocotb tests:\n')
        f.write('    from lcc_programs import get_program, EXPECTED_RESULTS\n')
        f.write('\n')
        f.write('    program = get_program("01_hello")\n')
        f.write('    expected = EXPECTED_RESULTS["01_hello"]\n')
        f.write('"""\n\n')

        # Expected results
        f.write('# Expected return values for each program\n')
        f.write('EXPECTED_RESULTS = {\n')
        f.write("    '01_hello': 42,\n")
        f.write("    '02_locals': 300,\n")
        f.write("    '03_arithmetic': 100,\n")
        f.write("    '04_globals': 15,\n")
        f.write("    '05_loop': 55,\n")
        f.write("    '06_array': 150,\n")
        f.write("    '07_factorial': 120,\n")
        f.write("    '08_fibonacci': 55,\n")
        f.write("    '09_bitwise': 8190,\n")
        f.write("    '10_char': 145,\n")
        f.write('}\n\n')

        # Program binaries
        f.write('# Program binaries as byte lists\n')
        f.write('PROGRAMS = {\n')

        for name, binary in sorted(programs.items()):
            # Format as list of hex values, 16 per line
            f.write(f"    '{name}': [\n")
            for i in range(0, len(binary), 16):
                chunk = binary[i:i+16]
                hex_vals = ", ".join(f"0x{b:02X}" for b in chunk)
                f.write(f"        {hex_vals},\n")
            f.write("    ],\n")

        f.write('}\n\n')

        # Helper functions
        f.write('\ndef get_program(name: str) -> list:\n')
        f.write('    """Get program bytes by name.\n')
        f.write('\n')
        f.write('    Args:\n')
        f.write('        name: Program name (e.g., "01_hello")\n')
        f.write('\n')
        f.write('    Returns:\n')
        f.write('        List of bytes\n')
        f.write('\n')
        f.write('    Raises:\n')
        f.write('        KeyError: If program not found\n')
        f.write('    """\n')
        f.write('    if name not in PROGRAMS:\n')
        f.write('        raise KeyError(f"Program not found: {name}")\n')
        f.write('    return PROGRAMS[name].copy()\n')
        f.write('\n\n')

        f.write('def list_programs() -> list:\n')
        f.write('    """List all available programs.\n')
        f.write('\n')
        f.write('    Returns:\n')
        f.write('        List of program names\n')
        f.write('    """\n')
        f.write('    return sorted(PROGRAMS.keys())\n')
        f.write('\n\n')

        f.write('def get_expected(name: str) -> int:\n')
        f.write('    """Get expected result for a program.\n')
        f.write('\n')
        f.write('    Args:\n')
        f.write('        name: Program name\n')
        f.write('\n')
        f.write('    Returns:\n')
        f.write('        Expected return value\n')
        f.write('    """\n')
        f.write('    return EXPECTED_RESULTS.get(name, 0)\n')
        f.write('\n\n')

        f.write('if __name__ == "__main__":\n')
        f.write('    print("Available programs:")\n')
        f.write('    for name in list_programs():\n')
        f.write('        size = len(PROGRAMS[name])\n')
        f.write('        expected = get_expected(name)\n')
        f.write('        print(f"  {name}: {size} bytes, expected={expected}")\n')

    print(f"Generated {OUTPUT_FILE}")

    if errors:
        print(f"\nWarning: {len(errors)} files failed to assemble:")
        for name, error in errors:
            print(f"  {name}: {error}")

    print(f"\nSuccess: {len(programs)} programs generated")


if __name__ == "__main__":
    main()
